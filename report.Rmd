---
title: "Analyse des Données NPHA"
author: "Anastasios Tsiompanidis et Noah Kohrs"
date: "`r Sys.Date()`"
---

# National Poll on Healthy Aging (NPHA)

## Auteurs du Projet
[Anastasios Tsiompanidis](anastasios.tsiompanidis@etu.univ-grenoble-alpes.fr)
[Noah Kohrs](noah.kohrs@etu.univ-grenoble-alpes.fr)

## 1- Motivation et Positionnement du Projet
Ce travail est basé sur le ["National Poll on Healthy Aging" (NPHA)](https://archive.ics.uci.edu/dataset/936/national+poll+on+healthy+aging+(npha)), une enquête menée auprès de personnes âgées pour évaluer leur état de santé et leurs besoins en matière de soins médicaux.

<... Introduction ...>

On précharge les librairies nécessaires pour l'analyse des données:
```{r, message=FALSE, warning=FALSE}
library(cluster)
library(rpart)
```

## 2- Analyse descriptive 
Une première lecture des données nous donne un aperçu des valeurs uniques pour chaque variable, ce qui nous permet de détecter d'éventuels problèmes de labellisation ou de valeurs manquantes.
```{r}
npha <- read.csv("NPHA-doctor-visits.csv")
summary(npha)
```

Comme nos valeurs sont catégorielles représentées par des chiffres, on va les remplacer par des labels pour une meilleure compréhension.

Cependant, le dataset utilisé contient plusieurs erreurs de labellisation, ce qui nous oblige à les corriger. Nous avons essayé dee faire au plus mieux pour rester cohérent avec les valeurs existantes.
```{r}
doctor_labels <- c("0-1", "2-3", "4+")
age_labels <- c("50-64", "65-80")

# On a ajouté la valeur "Very Poor" nous mêmes car il n'y avait
# pas de labelling indiqué pour la valeur 6. 
# Cela suit la logique et nous évite la présence de NA's 
health_labels <- c("Refused", "Excellent", "Very Good", "Good", "Fair", "Poor", "Very Poor")
empl_labels <- c("Refused", "Full-time", "Part-time", "Retired", "Not working")
yes_no_labels <- c("No", "Yes")
gender_labels <- c("M", "F")
medication_labels <- c("Refused", "Use regularly", "Use occasionally", "Do not use")

# Les valeurs devraient être "No" et "Yes", mais elles sont mal labellisées dans le dataset.
# Nous supposons que ces corrections sont appropriées.
sleep_labels <- c("Refused", "No", "A bit", "Yes")
race_labels <- c("Not asked", "Refused", "White", "Black", "Other", "Hispanic", "2+ Races")
```

Enfin, on utilise ces labels pour remplacer les valeurs existantes dans le dataset.

```{r}
colnames(npha)
npha$Number.of.Doctors.Visited = factor(npha$Number.of.Doctors.Visited, levels = 1:3, labels = doctor_labels, ordered = TRUE)
npha$Age = factor(npha$Age, levels = 1:2, labels = age_labels, ordered = FALSE)
npha$Physical.Health = factor(npha$Physical.Health, levels = c(-1, 1:6), labels = health_labels, ordered = TRUE)
npha$Mental.Health = factor(npha$Mental.Health, levels = c(-1, 1:6), labels = health_labels, ordered = TRUE)
npha$Dental.Health = factor(npha$Dental.Health, levels = c(-1, 1:6), labels = health_labels, ordered = TRUE)
npha$Employment = factor(npha$Employment, levels = c(-1, 1:4), labels = empl_labels, ordered = FALSE)
npha$Stress.Keeps.Patient.from.Sleeping = factor(npha$Stress.Keeps.Patient.from.Sleeping, levels = 0:1, labels = yes_no_labels, ordered = FALSE)
npha$Medication.Keeps.Patient.from.Sleeping = factor(npha$Medication.Keeps.Patient.from.Sleeping, levels = 0:1, labels = yes_no_labels, ordered = FALSE)
npha$Pain.Keeps.Patient.from.Sleeping = factor(npha$Pain.Keeps.Patient.from.Sleeping, levels = 0:1, labels = yes_no_labels, ordered = FALSE)
npha$Bathroom.Needs.Keeps.Patient.from.Sleeping = factor(npha$Bathroom.Needs.Keeps.Patient.from.Sleeping, levels = 0:1, labels = yes_no_labels, ordered = FALSE)
npha$Unknown.Keeps.Patient.from.Sleeping = factor(npha$Unknown.Keeps.Patient.from.Sleeping, levels = 0:1, labels = yes_no_labels, ordered = FALSE)
npha$Trouble.Sleeping = factor(npha$Trouble.Sleeping, levels = c(-1, 1:3), labels = sleep_labels, ordered = FALSE)
npha$Prescription.Sleep.Medication = factor(npha$Prescription.Sleep.Medication, levels = c(-1, 1:3), labels = medication_labels, ordered = FALSE)
npha$Race = factor(npha$Race, levels = 0:6, labels = race_labels, ordered = FALSE)
npha$Gender = factor(npha$Gender, levels = 1:2, labels = gender_labels, ordered = FALSE)

```
On obtient:

```{r}
summary(npha)
```

Ce resumé est bien plus parlant et nous permet de mieux comprendre les données que nous avons à disposition.

On observe par ailleurs que l'age des patients est toujours entre 65 et 80 ans, il s'agit donc d'une constante sur notre jeu de données. 
Nous allons donc écarter la variable de la suite de l'analyse car cela ne nous fournit aucune information utile et nuit la la lisibilité.

```{r}
npha <- npha[, c(1, 3:ncol(npha))]
# On vérifie que l'age a bien été supprimé.
colnames(npha)
```

Essayons d'avoir une vue d'ensemble de nos données.
```{r}
plot(npha)
```
Comme attendu, c'est indigeste en vu du nombre de variables présentes dans le jeu de données ainsi que de la présence excessive de variables catégorielles et non numériques.

On va donc essayer de voir les relations entre les variables et le nombre de visites chez le médecin.

```{r}

par(mfrow = c(2, 2))
boxplot(split(npha$Number.of.Doctors.Visited, npha$Employment), main = "Number of Doctors Visited by Employement Group")
boxplot(split(npha$Number.of.Doctors.Visited, npha$Physical.Health), main = "Number of Doctors Visited by Physical Health")
boxplot(split(npha$Number.of.Doctors.Visited, npha$Mental.Health), main = "Number of Doctors Visited by Mental Health")
boxplot(split(npha$Number.of.Doctors.Visited, npha$Dental.Health), main = "Number of Doctors Visited by Dental Health")
```

## 3- Classification non supervisée :
On effectue une analyse de regroupement hiérarchique et un clustering PAM pour segmenter 
les données sans inclure la variable cible, puis on visualise les résultats de chaque méthode.
```{r}
par(mfrow = c(1, 1))
# Suppression de la variable cible (Number.of.Doctors.Visited)
npha_sans_visites <- npha[, -1]
summary(npha_sans_visites)
```

<...>
```{r}
dist_matrix <- daisy(npha_sans_visites[, -ncol(npha_sans_visites)])
hclust_result <- hclust(dist_matrix)
plot(hclust_result)
```

<...>
```{r}
pam_result <- pam(npha_sans_visites[, -ncol(npha_sans_visites)], k = 2)
plot(pam_result)
```

### Interprétation du graphique de clustering PAM
Le graphique de clustering PAM met en évidence deux groupes principaux parmi les observations. 
Cependant, la séparation entre ces clusters n'est pas nette, indiquant une certaine 
hétérogénéité au sein des groupes. L'explication de la variance à hauteur de 31,54 % suggère 
que les deux premières composantes principales ne capturent qu'une partie limitée des informations 
contenues dans les données. Cette faible variance implique que d'autres dimensions pourraient 
être nécessaires pour mieux différencier les groupes. De plus, la dispersion des points montre 
que certains individus sont proches de la frontière entre les clusters, suggérant que les variables 
choisies ne permettent pas de segmenter clairement la population analysée.

### Interprétation du Silhouette Plot
Le Silhouette Plot révèle une cohésion interne relativement faible des clusters, avec une valeur 
moyenne de 0,17. Ce score indique que de nombreuses observations se situent à la limite de leur 
groupe, ce qui traduit une séparation imparfaite entre les clusters. En particulier, le premier 
cluster présente une silhouette moyenne plus basse, ce qui signifie que ses individus sont plus 
dispersés et donc moins homogènes. À l'inverse, le second cluster semble mieux défini, bien que 
sa cohésion reste modérée. Globalement, ces résultats suggèrent que le choix du nombre de clusters 
pourrait être optimisé ou que certaines variables devraient être réévaluées pour améliorer la qualité 
de la classification.

## 4- Classification supervisée:

On commence par récuperer les indices pour chaque catégorie de la variable cible.
On a observé qu'aucune classe ne justifierait un sous-échantillonage pour maximiser la classe.
```{r}
# Ici aucun class est assez rare pour faire un max d'une classe

indices_1 <- which(npha$Number.of.Doctors.Visited == "0-1")
indices_2 <- which(npha$Number.of.Doctors.Visited == "2-3")
indices_3 <- which(npha$Number.of.Doctors.Visited == "4 or more")

sample_1 <- sample(indices_1, round(0.6 * length(indices_1), digits = 0))
sample_2 <- sample(indices_2, round(0.6 * length(indices_2), digits = 0))
sample_3 <- sample(indices_3, round(0.6 * length(indices_3), digits = 0))
sub <- c(sample_1, sample_2, sample_3)
```

Voir la longueur des indices permet de vérifier la taille de chaque
sous-ensemble de données, ce qui est crucial pour évaluer si chaque
catégorie est suffisamment représentée.
```{r}
length(indices_1)
length(indices_2)
length(indices_3)
```

On entraîne un modèle de classification rpart sur un sous-ensemble de 
données et on évalue ses prédictions en comparant les résultats sur un 
jeu de test excluant ces mêmes indices.
```{r}
fit <- rpart(npha$Number.of.Doctors.Visited ~ ., data = npha, subset = sub)
fit
plot(fit)
res <- table(predict(fit, npha[-sub, ], type = "class"), npha[-sub, "Number.of.Doctors.Visited"])
res
```

On calcule le taux d'erreur du modèle en comparant les prédictions 
correctes aux résultats totaux, puis on l'affiche sous forme de pourcentage.
```{r}
err <- (1 - sum(diag(res)) / sum(res)) * 100
cat("Le taux d'erreur est de :", err, "%\n")
```
